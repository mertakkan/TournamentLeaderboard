================================================================================
FILE: F:\Unity\TournamentLeaderboard\Assets\Scripts\Data\JSONGenerator.cs
================================================================================

using System.Collections.Generic;
using System.IO;
using UnityEngine;

public class JSONGenerator : MonoBehaviour
{
    [Header("JSON Generation Settings")]
    [SerializeField]
    private int totalPlayers = 1000;

    [SerializeField]
    private string fileName = "tournament_data.json";

    [ContextMenu("Generate JSON File")]
    public void GenerateJSONFile()
    {
        TournamentData tournamentData = new TournamentData();

        // Add the "me" player first
        int meScore = Random.Range(400, 1200);
        tournamentData.players.Add(new PlayerData("me", "Me", meScore));

        // Sample names (same as your current generator)
        string[] sampleNames =
        {
            "DragonSlayer",
            "ShadowHunter",
            "FireWizard",
            "IceQueen",
            "ThunderLord",
            "MysticWarrior",
            "CrystalMage",
            "StormRider",
            "PhoenixKnight",
            "VoidMaster",
            "LightningBolt",
            "FrostGiant",
            "BlazeFury",
            "WindWalker",
            "EarthShaker",
            "StarCrusher",
            "MoonBlade",
            "SunBurst",
            "NightCrawler",
            "DayBreaker",
            "SuperLongPlayerNameThatShouldBeTruncated",
            "AnotherVeryLongName",
            "XxDarkDestroyerxX",
            "Player",
            "Gamer",
            "Champion",
            "Legend",
            "Master",
            "Warrior",
            "Knight",
            "Mage",
            "Archer",
            "Rogue",
            "Paladin",
            "Sorcerer",
            "Ninja",
            "Samurai",
            "Viking",
            "Gladiator",
            "Barbarian",
            "Assassin",
            "Ranger",
            "Wizard",
            "Necromancer",
            "Demon",
            "Angel",
            "Phoenix",
            "Dragon"
        };

        // Generate the remaining 999 players
        for (int i = 1; i < totalPlayers; i++)
        {
            string id = $"user_{i:000}";
            string nickname =
                sampleNames[Random.Range(0, sampleNames.Length)] + Random.Range(1, 999);
            int score = Random.Range(200, 2500);

            tournamentData.players.Add(new PlayerData(id, nickname, score));
        }

        // Convert to JSON
        string json = JsonUtility.ToJson(tournamentData, true);

        // Save to StreamingAssets folder
        string streamingAssetsPath = Path.Combine(Application.streamingAssetsPath, fileName);

        // Create StreamingAssets folder if it doesn't exist
        if (!Directory.Exists(Application.streamingAssetsPath))
        {
            Directory.CreateDirectory(Application.streamingAssetsPath);
        }

        // Write the JSON file
        File.WriteAllText(streamingAssetsPath, json);

        Debug.Log($"JSON file generated successfully at: {streamingAssetsPath}");
        Debug.Log($"Generated {tournamentData.players.Count} players");

        // Also save a copy in the project for easier access
        string projectPath = Path.Combine(Application.dataPath, "StreamingAssets", fileName);
        File.WriteAllText(projectPath, json);

#if UNITY_EDITOR
        UnityEditor.AssetDatabase.Refresh();
#endif
    }
}


================================================================================
FILE: F:\Unity\TournamentLeaderboard\Assets\Scripts\Data\PlayerData.cs
================================================================================

using System;

[Serializable]
public class PlayerData
{
    public string id;
    public string nickname;
    public int score;

    [NonSerialized]
    public int rank;

    public bool IsCurrentPlayer => id == "me";

    public PlayerData(string id, string nickname, int score)
    {
        this.id = id;
        this.nickname = nickname;
        this.score = score;
    }

    public PlayerData Clone()
    {
        return new PlayerData(id, nickname, score);
    }
}


================================================================================
FILE: F:\Unity\TournamentLeaderboard\Assets\Scripts\Data\TournamentData.cs
================================================================================

using System;
using System.Collections.Generic;

[Serializable]
public class TournamentData
{
    public List<PlayerData> players;

    public TournamentData()
    {
        players = new List<PlayerData>();
    }
}


================================================================================
FILE: F:\Unity\TournamentLeaderboard\Assets\Scripts\Managers\DataManager.cs
================================================================================

using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;

public class DataManager : MonoBehaviour
{
    [Header("Data Settings")]
    [SerializeField]
    private string jsonFileName = "tournament_data.json";

    [SerializeField]
    private bool useStreamingAssets = true;

    [SerializeField]
    private TextAsset jsonFile; // Fallback for Resources folder

    private TournamentData tournamentData;
    private List<PlayerData> originalPlayers;

    public static DataManager Instance { get; private set; }

    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    void Start()
    {
        LoadTournamentData();
    }

    private void LoadTournamentData()
    {
        string jsonString = null;

        if (useStreamingAssets)
        {
            // Load from StreamingAssets folder
            string filePath = Path.Combine(Application.streamingAssetsPath, jsonFileName);

            if (File.Exists(filePath))
            {
                jsonString = File.ReadAllText(filePath);
                Debug.Log($"Loaded tournament data from StreamingAssets: {filePath}");
            }
            else
            {
                Debug.LogWarning($"JSON file not found at: {filePath}");
            }
        }
        else if (jsonFile != null)
        {
            // Load from Resources (TextAsset)
            jsonString = jsonFile.text;
            Debug.Log("Loaded tournament data from TextAsset");
        }

        if (!string.IsNullOrEmpty(jsonString))
        {
            try
            {
                tournamentData = JsonUtility.FromJson<TournamentData>(jsonString);
                Debug.Log($"Successfully parsed {tournamentData.players.Count} players from JSON");
            }
            catch (System.Exception e)
            {
                Debug.LogError($"Failed to parse JSON: {e.Message}");
                tournamentData = null;
            }
        }

        // Fallback to generated data if JSON loading failed
        if (tournamentData == null || tournamentData.players.Count == 0)
        {
            Debug.LogWarning("JSON loading failed, generating sample data...");
            GenerateSampleData();
        }

        // Store original data for reference
        originalPlayers = new List<PlayerData>();
        foreach (var player in tournamentData.players)
        {
            originalPlayers.Add(player.Clone());
        }

        SortAndRankPlayers();
    }

    private void GenerateSampleData()
    {
        tournamentData = new TournamentData();

        // Add the "me" player with a random starting rank for better demo
        int meScore = Random.Range(400, 1200);
        tournamentData.players.Add(new PlayerData("me", "Me", meScore));

        // More realistic player names for testing
        string[] sampleNames =
        {
            "DragonSlayer",
            "ShadowHunter",
            "FireWizard",
            "IceQueen",
            "ThunderLord",
            "MysticWarrior",
            "CrystalMage",
            "StormRider",
            "PhoenixKnight",
            "VoidMaster",
            "LightningBolt",
            "FrostGiant",
            "BlazeFury",
            "WindWalker",
            "EarthShaker",
            "StarCrusher",
            "MoonBlade",
            "SunBurst",
            "NightCrawler",
            "DayBreaker",
            "SuperLongPlayerNameThatShouldBeTruncated",
            "AnotherVeryLongName",
            "XxDarkDestroyerxX",
            "Player",
            "Gamer",
            "Champion",
            "Legend",
            "Master"
        };

        // Generate 999 other players with wider score range
        for (int i = 1; i < 1000; i++)
        {
            string id = $"user_{i:000}";
            string nickname =
                sampleNames[Random.Range(0, sampleNames.Length)] + Random.Range(1, 999);
            int score = Random.Range(200, 2500);

            tournamentData.players.Add(new PlayerData(id, nickname, score));
        }
    }

    public List<PlayerData> GetSortedPlayers()
    {
        return tournamentData.players.OrderByDescending(p => p.score).ToList();
    }

    public PlayerData GetCurrentPlayer()
    {
        return tournamentData.players.FirstOrDefault(p => p.IsCurrentPlayer);
    }

    public void UpdateScoresRandomly()
    {
        var mePlayer = GetCurrentPlayer();

        foreach (var player in tournamentData.players)
        {
            if (player.IsCurrentPlayer)
            {
                // Give "me" player a bigger chance for significant score increases
                if (Random.Range(0f, 1f) < 0.8f) // 80% chance for me to get an update
                {
                    int increase = Random.Range(50, 400); // Larger increases for dramatic rank changes
                    player.score += increase;
                }
            }
            else
            {
                // Other players get smaller, less frequent updates
                if (Random.Range(0f, 1f) < 0.25f) // 25% chance for others
                {
                    int increase = Random.Range(5, 150); // Smaller increases
                    player.score += increase;
                }
            }
        }

        SortAndRankPlayers();
    }

    private void SortAndRankPlayers()
    {
        var sortedPlayers = tournamentData.players.OrderByDescending(p => p.score).ToList();

        for (int i = 0; i < sortedPlayers.Count; i++)
        {
            sortedPlayers[i].rank = i + 1;
        }

        tournamentData.players = sortedPlayers;
    }

    public int GetPlayerRank(string playerId)
    {
        var player = tournamentData.players.FirstOrDefault(p => p.id == playerId);
        return player?.rank ?? -1;
    }
}


================================================================================
FILE: F:\Unity\TournamentLeaderboard\Assets\Scripts\Managers\GameManager.cs
================================================================================

using UnityEngine;

public class GameManager : MonoBehaviour
{
    [Header("Prefabs")]
    [SerializeField]
    private LeaderboardView leaderboardViewPrefab;

    private LeaderboardView leaderboardView;

    void Start()
    {
        SetupGame();
    }

    private void SetupGame()
    {
        // Create leaderboard view
        if (leaderboardViewPrefab != null)
        {
            leaderboardView = Instantiate(leaderboardViewPrefab);
        }
        else
        {
            Debug.LogError("LeaderboardView prefab is not assigned!");
        }
    }
}


================================================================================
FILE: F:\Unity\TournamentLeaderboard\Assets\Scripts\UI\LeaderboardEntry.cs
================================================================================

using DG.Tweening;
using TMPro;
using UnityEngine;

public class LeaderboardEntry : MonoBehaviour
{
    [Header("Visual Components")]
    [SerializeField]
    private SpriteRenderer backgroundRenderer;

    [SerializeField]
    private SpriteRenderer rankBackgroundRenderer;

    [SerializeField]
    private SpriteRenderer profileIconRenderer;

    [SerializeField]
    private SpriteRenderer borderRenderer; // Add border for Clash of Clans style

    [SerializeField]
    private TextMeshPro rankText;

    [SerializeField]
    private TextMeshPro nicknameText;

    [SerializeField]
    private TextMeshPro scoreText;

    [Header("Colors - Clash of Clans Style")]
    [SerializeField]
    private Color normalColor = new Color(0.95f, 0.9f, 0.8f, 1f); // Warm beige

    [SerializeField]
    private Color currentPlayerColor = new Color(1f, 0.85f, 0.3f, 1f); // Golden

    [SerializeField]
    private Color topRankColor = new Color(0.9f, 0.95f, 1f, 1f); // Light blue

    [SerializeField]
    private Color borderColor = new Color(0.4f, 0.3f, 0.2f, 1f); // Dark brown border

    [Header("Rank Colors")]
    [SerializeField]
    private Color goldColor = new Color(1f, 0.84f, 0f);

    [SerializeField]
    private Color silverColor = new Color(0.75f, 0.75f, 0.75f);

    [SerializeField]
    private Color bronzeColor = new Color(0.8f, 0.5f, 0.2f);

    [SerializeField]
    private Color defaultRankColor = new Color(0.5f, 0.4f, 0.3f);

    [Header("Text Settings")]
    [SerializeField]
    private int maxNicknameLength = 10;

    [SerializeField]
    private float nicknameMaxWidth = 2.5f; // Maximum width for nickname text

    [Header("Rank Text Scaling")]
    [SerializeField]
    private float baseFontSize = 12f;

    [SerializeField]
    private float minFontSize = 6f;

    private PlayerData playerData;
    private bool isCurrentPlayer;
    private Vector3 originalScale;

    public PlayerData PlayerData => playerData;
    public bool IsCurrentPlayer => isCurrentPlayer;
    public string PlayerId => playerData?.id;

    void Awake()
    {
        originalScale = transform.localScale;
        SetupTextProperties();
        SetupVisualElements();
    }

    private void SetupTextProperties()
    {
        // Setup rank text with dynamic scaling
        if (rankText != null)
        {
            rankText.fontSize = baseFontSize;
            rankText.fontStyle = FontStyles.Bold;
            rankText.alignment = TextAlignmentOptions.Center;
            rankText.color = Color.white;
            rankText.sortingOrder = 12;
        }

        // Setup nickname text with proper constraints
        if (nicknameText != null)
        {
            nicknameText.fontSize = 6f;
            nicknameText.fontStyle = FontStyles.Bold;
            nicknameText.alignment = TextAlignmentOptions.Center;
            nicknameText.color = new Color(0.2f, 0.15f, 0.1f);
            nicknameText.sortingOrder = 12;
            nicknameText.enableWordWrapping = false;
            nicknameText.overflowMode = TextOverflowModes.Truncate;
        }

        // Setup score text
        if (scoreText != null)
        {
            scoreText.fontSize = 7f;
            scoreText.fontStyle = FontStyles.Bold;
            scoreText.alignment = TextAlignmentOptions.Center;
            scoreText.color = new Color(0.3f, 0.2f, 0.1f);
            scoreText.sortingOrder = 12;
        }
    }

    private void SetupVisualElements()
    {
        // Setup background
        if (backgroundRenderer != null)
        {
            backgroundRenderer.sortingOrder = 5;
        }

        // Setup border
        if (borderRenderer != null)
        {
            borderRenderer.color = borderColor;
            borderRenderer.sortingOrder = 6;
        }

        // Setup rank background
        if (rankBackgroundRenderer != null)
        {
            rankBackgroundRenderer.sortingOrder = 8;
        }

        // Setup profile icon
        if (profileIconRenderer != null)
        {
            profileIconRenderer.sortingOrder = 9;
        }
    }

    public void SetupEntry(PlayerData data, bool isCurrentPlayerEntry = false)
    {
        playerData = data;
        isCurrentPlayer = isCurrentPlayerEntry;

        UpdateVisuals();
        UpdateColors();
        PositionElements();
    }

    private void UpdateVisuals()
    {
        if (playerData == null)
            return;

        // Update rank with dynamic font scaling
        if (rankText != null)
        {
            rankText.text = playerData.rank.ToString();
            ScaleRankTextToFit();
        }

        // Update nickname with proper truncation
        if (nicknameText != null)
        {
            SetNicknameWithConstraints(playerData.nickname);
        }

        // Update score with proper formatting
        if (scoreText != null)
            scoreText.text = FormatScore(playerData.score);
    }

    private void ScaleRankTextToFit()
    {
        if (rankText == null || rankBackgroundRenderer == null)
            return;

        // Get the available width/height from the rank background
        float availableWidth = rankBackgroundRenderer.bounds.size.x * 0.8f; // 80% of background width
        float availableHeight = rankBackgroundRenderer.bounds.size.y * 0.8f; // 80% of background height

        // Start with base font size and scale down if needed
        float currentFontSize = baseFontSize;
        rankText.fontSize = currentFontSize;
        rankText.ForceMeshUpdate();

        // Check if text fits within the available space
        while (
            (rankText.preferredWidth > availableWidth || rankText.preferredHeight > availableHeight)
            && currentFontSize > minFontSize
        )
        {
            currentFontSize -= 0.5f;
            rankText.fontSize = currentFontSize;
            rankText.ForceMeshUpdate();
        }

        // Ensure minimum font size
        if (currentFontSize < minFontSize)
        {
            rankText.fontSize = minFontSize;
        }
    }

    private void SetNicknameWithConstraints(string nickname)
    {
        if (nicknameText == null)
            return;

        // First, try the original nickname
        nicknameText.text = nickname;
        nicknameText.ForceMeshUpdate();

        // If it's too wide, truncate it
        if (nicknameText.preferredWidth > nicknameMaxWidth)
        {
            string truncated = nickname;
            int length = nickname.Length;

            // Keep reducing until it fits
            while (nicknameText.preferredWidth > nicknameMaxWidth && length > 3)
            {
                length--;
                truncated = nickname.Substring(0, length) + "...";
                nicknameText.text = truncated;
                nicknameText.ForceMeshUpdate();
            }
        }
    }

    private string FormatScore(int score)
    {
        if (score >= 1000000)
            return $"{score / 1000000f:F1}M";
        else if (score >= 1000)
            return $"{score / 1000f:F1}K";
        else
            return score.ToString("N0");
    }

    private void PositionElements()
    {
        if (backgroundRenderer == null)
            return;

        float bgWidth = backgroundRenderer.bounds.size.x;
        float bgHeight = backgroundRenderer.bounds.size.y;

        // Position rank elements on the far left
        if (rankBackgroundRenderer != null)
        {
            rankBackgroundRenderer.transform.localPosition = new Vector3(-bgWidth * 0.4f, 0, 0);
        }
        if (rankText != null)
        {
            rankText.transform.localPosition = new Vector3(-bgWidth * 0.4f, 0, -0.1f);
        }

        // Position profile icon
        if (profileIconRenderer != null)
        {
            profileIconRenderer.transform.localPosition = new Vector3(-bgWidth * 0.2f, 0, 0);
        }

        // Position nickname with proper spacing
        if (nicknameText != null)
        {
            nicknameText.transform.localPosition = new Vector3(-bgWidth * 0.05f, 0, -0.1f);
        }

        // Position score on the right
        if (scoreText != null)
        {
            scoreText.transform.localPosition = new Vector3(bgWidth * 0.35f, 0, -0.1f);
        }
    }

    private void UpdateColors()
    {
        Color bgColor = normalColor;
        Color textColor = new Color(0.2f, 0.15f, 0.1f);

        if (isCurrentPlayer)
        {
            bgColor = currentPlayerColor;
            textColor = new Color(0.1f, 0.05f, 0.0f);
        }
        else if (playerData != null && playerData.rank <= 3)
        {
            bgColor = topRankColor;
            textColor = new Color(0.1f, 0.1f, 0.2f);
        }

        // Apply colors
        if (backgroundRenderer != null)
            backgroundRenderer.color = bgColor;

        if (nicknameText != null)
            nicknameText.color = textColor;

        if (scoreText != null)
            scoreText.color = textColor;

        // Update rank colors
        if (rankBackgroundRenderer != null && playerData != null)
        {
            rankBackgroundRenderer.color = GetRankColor(playerData.rank);
        }

        if (profileIconRenderer != null && playerData != null)
        {
            profileIconRenderer.color = GetProfileIconColor(playerData.rank);
        }

        // Update border for current player
        if (borderRenderer != null)
        {
            if (isCurrentPlayer)
            {
                borderRenderer.color = new Color(1f, 0.8f, 0.2f, 1f); // Golden border
            }
            else
            {
                borderRenderer.color = borderColor;
            }
        }
    }

    private Color GetRankColor(int rank)
    {
        switch (rank)
        {
            case 1:
                return goldColor;
            case 2:
                return silverColor;
            case 3:
                return bronzeColor;
            default:
                return defaultRankColor;
        }
    }

    private Color GetProfileIconColor(int rank)
    {
        if (rank <= 10)
            return new Color(0.9f, 0.7f, 0.3f);
        else if (rank <= 100)
            return new Color(0.7f, 0.7f, 0.9f);
        else
            return new Color(0.6f, 0.6f, 0.6f);
    }

    public Tween AnimateToPosition(Vector3 targetPosition, float duration = 0.5f)
    {
        return transform.DOMove(targetPosition, duration).SetEase(Ease.OutQuart);
    }

    public Tween AnimateScale(float scale, float duration = 0.3f)
    {
        return transform.DOScale(originalScale * scale, duration).SetEase(Ease.OutBack);
    }

    public void ResetScale()
    {
        transform.localScale = originalScale;
    }

    public void SetActive(bool active)
    {
        gameObject.SetActive(active);
    }

    public void UpdateData(PlayerData newData)
    {
        playerData = newData;
        UpdateVisuals();
        UpdateColors();
    }

    public Tween PlayEntryAnimation()
    {
        Vector3 startScale = Vector3.zero;
        transform.localScale = startScale;

        return transform
            .DOScale(originalScale, 0.3f)
            .SetEase(Ease.OutBack)
            .SetDelay(Random.Range(0f, 0.1f));
    }

    public Sequence PlayHighlightAnimation()
    {
        var sequence = DOTween.Sequence();
        sequence.Append(transform.DOScale(originalScale * 1.1f, 0.2f));
        sequence.Append(transform.DOScale(originalScale, 0.2f));
        sequence.SetEase(Ease.OutQuart);
        return sequence;
    }
}


================================================================================
FILE: F:\Unity\TournamentLeaderboard\Assets\Scripts\UI\LeaderboardView.cs
================================================================================

using System.Collections;
using System.Collections.Generic;
using System.Linq;
using DG.Tweening;
using UnityEngine;

public class LeaderboardView : MonoBehaviour
{
    [Header("Settings")]
    [SerializeField]
    private LeaderboardEntry entryPrefab;

    [SerializeField]
    private UpdateButton updateButtonPrefab;

    [SerializeField]
    private int visibleEntries = 10;

    [SerializeField]
    private float entrySpacing = 1.4f;

    [SerializeField]
    private float animationDuration = 0.6f;

    [SerializeField]
    private int minRankChangeForScrollAnimation = 5; // Minimum rank change to trigger scroll animation

    [SerializeField]
    private int maxAnimationSteps = 15; // Maximum number of animation steps

    [Header("Layout")]
    [SerializeField]
    private Transform entriesContainer;

    [SerializeField]
    private Transform uiContainer;

    [Header("Background")]
    [SerializeField]
    private SpriteRenderer backgroundRenderer;

    private ObjectPool<LeaderboardEntry> entryPool;
    private List<LeaderboardEntry> activeEntries = new List<LeaderboardEntry>();
    private List<PlayerData> currentPlayers = new List<PlayerData>();

    private UpdateButton updateButton;
    private LeaderboardEntry currentPlayerEntry;
    private int currentPlayerIndex;
    private bool isAnimating = false;

    // Better position tracking
    private Dictionary<int, Vector3> slotPositions = new Dictionary<int, Vector3>();

    public static LeaderboardView Instance { get; private set; }

    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }

    void Start()
    {
        SetupLeaderboard();
    }

    private void SetupLeaderboard()
    {
        CreateContainers();
        SetupBackground();
        InitializePool();
        CreateUpdateButton();
        StartCoroutine(WaitForDataAndDisplay());
    }

    private void CreateContainers()
    {
        if (entriesContainer == null)
        {
            GameObject container = new GameObject("EntriesContainer");
            container.transform.SetParent(transform);
            entriesContainer = container.transform;
        }

        if (uiContainer == null)
        {
            GameObject container = new GameObject("UIContainer");
            container.transform.SetParent(transform);
            uiContainer = container.transform;
        }
    }

    private void SetupBackground()
    {
        if (backgroundRenderer == null)
        {
            GameObject bgObj = new GameObject("Background");
            bgObj.transform.SetParent(transform);
            backgroundRenderer = bgObj.AddComponent<SpriteRenderer>();
        }

        // Clash of Clans style background
        backgroundRenderer.color = new Color(0.15f, 0.25f, 0.4f, 0.9f);
        backgroundRenderer.transform.localScale = new Vector3(14f, 18f, 1f);
        backgroundRenderer.sortingOrder = -1;
    }

    private void InitializePool()
    {
        entryPool = new ObjectPool<LeaderboardEntry>(
            entryPrefab,
            entriesContainer,
            visibleEntries + 15
        );
    }

    private void CreateUpdateButton()
    {
        updateButton = Instantiate(updateButtonPrefab, uiContainer);
        updateButton.transform.position = new Vector3(0, 7f, 0);
        updateButton.OnButtonClicked += OnUpdateButtonClicked;
    }

    private IEnumerator WaitForDataAndDisplay()
    {
        yield return new WaitUntil(() => DataManager.Instance != null);
        DisplayLeaderboard();
    }

    public void DisplayLeaderboard()
    {
        var sortedPlayers = DataManager.Instance.GetSortedPlayers();
        currentPlayers = new List<PlayerData>(sortedPlayers);
        currentPlayerIndex = currentPlayers.FindIndex(p => p.IsCurrentPlayer);

        CalculateSlotPositions();
        DisplayVisibleEntries();
    }

    private void CalculateSlotPositions()
    {
        slotPositions.Clear();

        for (int i = 0; i < visibleEntries; i++)
        {
            float yPosition = (visibleEntries / 2f - i - 0.5f) * entrySpacing;
            slotPositions[i] = new Vector3(0, yPosition, 0);
        }
    }

    private void DisplayVisibleEntries()
    {
        // Clear all existing entries
        entryPool.ReturnAll(activeEntries);
        activeEntries.Clear();

        // Calculate visible range
        int startIndex = CalculateStartIndex(currentPlayerIndex);
        int endIndex = Mathf.Min(currentPlayers.Count, startIndex + visibleEntries);

        // Create entries for visible range
        for (int i = startIndex; i < endIndex; i++)
        {
            CreateEntryAtSlot(i, i - startIndex);
        }
    }

    private int CalculateStartIndex(int playerIndex)
    {
        int startIndex = Mathf.Max(0, playerIndex - visibleEntries / 2);
        int maxStartIndex = Mathf.Max(0, currentPlayers.Count - visibleEntries);
        return Mathf.Min(startIndex, maxStartIndex);
    }

    private void CreateEntryAtSlot(int playerIndex, int slotIndex)
    {
        if (slotIndex < 0 || slotIndex >= visibleEntries)
            return;

        var entry = entryPool.Get();
        var player = currentPlayers[playerIndex];
        bool isCurrentPlayer = player.IsCurrentPlayer;

        entry.SetupEntry(player, isCurrentPlayer);
        entry.transform.position = slotPositions[slotIndex];

        activeEntries.Add(entry);

        if (isCurrentPlayer)
        {
            currentPlayerEntry = entry;
        }

        entry.PlayEntryAnimation();
    }

    private void OnUpdateButtonClicked()
    {
        if (isAnimating)
            return;
        StartCoroutine(UpdateLeaderboard());
    }

    private IEnumerator UpdateLeaderboard()
    {
        isAnimating = true;
        updateButton.SetInteractable(false);

        // Get updated data
        DataManager.Instance.UpdateScoresRandomly();
        var newSortedPlayers = DataManager.Instance.GetSortedPlayers();
        int newPlayerIndex = newSortedPlayers.FindIndex(p => p.IsCurrentPlayer);

        // Perform the update with scroll animation if needed
        yield return StartCoroutine(PerformLeaderboardUpdate(newSortedPlayers, newPlayerIndex));

        // Update state
        currentPlayers = new List<PlayerData>(newSortedPlayers);
        currentPlayerIndex = newPlayerIndex;

        isAnimating = false;
        updateButton.SetInteractable(true);
    }

    private IEnumerator PerformLeaderboardUpdate(List<PlayerData> newPlayers, int newPlayerIndex)
    {
        int oldPlayerIndex = currentPlayerIndex;
        int rankChange = Mathf.Abs(newPlayerIndex - oldPlayerIndex);

        // Use scroll-through animation for significant rank changes
        if (rankChange >= minRankChangeForScrollAnimation && currentPlayerEntry != null)
        {
            yield return StartCoroutine(
                PerformScrollThroughAnimation(newPlayers, oldPlayerIndex, newPlayerIndex)
            );
        }
        else
        {
            // Use existing logic for small changes
            int newStartIndex = CalculateStartIndex(newPlayerIndex);
            yield return StartCoroutine(
                PerformStandardUpdate(newPlayers, newPlayerIndex, newStartIndex)
            );
        }
    }

    private IEnumerator PerformScrollThroughAnimation(
        List<PlayerData> newPlayers,
        int oldPlayerIndex,
        int newPlayerIndex
    )
    {
        // Calculate animation parameters
        int totalSteps = Mathf.Min(Mathf.Abs(newPlayerIndex - oldPlayerIndex), maxAnimationSteps);
        float stepDuration = animationDuration / totalSteps;

        // Animate through intermediate positions
        for (int step = 1; step <= totalSteps; step++)
        {
            float progress = (float)step / totalSteps;
            int intermediateIndex = Mathf.RoundToInt(
                Mathf.Lerp(oldPlayerIndex, newPlayerIndex, progress)
            );
            int intermediateStartIndex = CalculateStartIndex(intermediateIndex);

            // Update view for this intermediate position
            yield return StartCoroutine(
                UpdateViewForAnimationStep(newPlayers, intermediateStartIndex, stepDuration)
            );
        }

        // Final positioning with highlight
        int finalStartIndex = CalculateStartIndex(newPlayerIndex);
        yield return StartCoroutine(
            PerformStandardUpdate(newPlayers, newPlayerIndex, finalStartIndex, true)
        );
    }

    private IEnumerator UpdateViewForAnimationStep(
        List<PlayerData> newPlayers,
        int startIndex,
        float duration
    )
    {
        // Create mapping of old entries by player ID
        var entryMap = new Dictionary<string, LeaderboardEntry>();
        foreach (var entry in activeEntries)
        {
            if (entry.PlayerData != null)
            {
                entryMap[entry.PlayerData.id] = entry;
            }
        }

        // Clear active entries list but keep the objects
        activeEntries.Clear();

        // Calculate new visible range
        int endIndex = Mathf.Min(newPlayers.Count, startIndex + visibleEntries);

        // Update and position all entries
        var animations = new List<Tween>();

        for (int i = startIndex; i < endIndex; i++)
        {
            var player = newPlayers[i];
            int slotIndex = i - startIndex;
            Vector3 targetPosition = slotPositions[slotIndex];

            LeaderboardEntry entry;

            if (entryMap.ContainsKey(player.id))
            {
                // Reuse existing entry
                entry = entryMap[player.id];
                entry.UpdateData(player);
                entryMap.Remove(player.id);
            }
            else
            {
                // Create new entry
                entry = entryPool.Get();
                entry.SetupEntry(player, player.IsCurrentPlayer);
            }

            activeEntries.Add(entry);

            if (player.IsCurrentPlayer)
            {
                currentPlayerEntry = entry;
            }

            // Animate to target position
            if (Vector3.Distance(entry.transform.position, targetPosition) > 0.1f)
            {
                var tween = entry.AnimateToPosition(targetPosition, duration);
                animations.Add(tween);
            }
            else
            {
                entry.transform.position = targetPosition;
            }
        }

        // Return unused entries to pool
        foreach (var unusedEntry in entryMap.Values)
        {
            entryPool.Return(unusedEntry);
        }

        // Wait for animations to complete
        if (animations.Count > 0)
        {
            yield return new WaitForSeconds(duration);
        }

        // Ensure positions are exact to prevent overlaps
        for (int i = 0; i < activeEntries.Count; i++)
        {
            if (i < slotPositions.Count)
            {
                activeEntries[i].transform.position = slotPositions[i];
            }
        }
    }

    private IEnumerator PerformStandardUpdate(
        List<PlayerData> newPlayers,
        int playerIndex,
        int startIndex,
        bool showHighlight = false
    )
    {
        // Create mapping of old entries by player ID
        var entryMap = new Dictionary<string, LeaderboardEntry>();
        foreach (var entry in activeEntries)
        {
            if (entry.PlayerData != null)
            {
                entryMap[entry.PlayerData.id] = entry;
            }
        }

        // Clear active entries list but keep the objects
        activeEntries.Clear();

        // Calculate new visible range
        int endIndex = Mathf.Min(newPlayers.Count, startIndex + visibleEntries);

        // Phase 1: Update and position all entries
        var animations = new List<Tween>();

        for (int i = startIndex; i < endIndex; i++)
        {
            var player = newPlayers[i];
            int slotIndex = i - startIndex;
            Vector3 targetPosition = slotPositions[slotIndex];

            LeaderboardEntry entry;

            if (entryMap.ContainsKey(player.id))
            {
                // Reuse existing entry
                entry = entryMap[player.id];
                entry.UpdateData(player);
                entryMap.Remove(player.id);
            }
            else
            {
                // Create new entry
                entry = entryPool.Get();
                entry.SetupEntry(player, player.IsCurrentPlayer);
            }

            activeEntries.Add(entry);

            if (player.IsCurrentPlayer)
            {
                currentPlayerEntry = entry;
            }

            // Animate to target position
            if (Vector3.Distance(entry.transform.position, targetPosition) > 0.1f)
            {
                var tween = entry.AnimateToPosition(targetPosition, animationDuration);
                animations.Add(tween);
            }
            else
            {
                entry.transform.position = targetPosition;
            }
        }

        // Return unused entries to pool
        foreach (var unusedEntry in entryMap.Values)
        {
            entryPool.Return(unusedEntry);
        }

        // Phase 2: Highlight current player if requested
        if (showHighlight && currentPlayerEntry != null)
        {
            currentPlayerEntry.PlayHighlightAnimation();
        }

        // Wait for animations to complete
        if (animations.Count > 0)
        {
            yield return new WaitForSeconds(animationDuration);
        }

        // Ensure all positions are exact
        for (int i = 0; i < activeEntries.Count; i++)
        {
            if (i < slotPositions.Count)
            {
                activeEntries[i].transform.position = slotPositions[i];
            }
        }

        yield return null;
    }
}


================================================================================
FILE: F:\Unity\TournamentLeaderboard\Assets\Scripts\UI\UpdateButton.cs
================================================================================

using System;
using DG.Tweening;
using TMPro;
using UnityEngine;

public class UpdateButton : MonoBehaviour
{
    [Header("Visual Components")]
    [SerializeField]
    private SpriteRenderer backgroundRenderer;

    [SerializeField]
    private SpriteRenderer iconRenderer; // Add refresh icon

    [SerializeField]
    private TextMeshPro buttonText;

    [Header("Animation Settings")]
    [SerializeField]
    private float hoverScale = 1.05f;

    [SerializeField]
    private float clickScale = 0.95f;

    [SerializeField]
    private float animationDuration = 0.15f;

    [Header("Colors")]
    [SerializeField]
    private Color normalColor = new Color(0.3f, 0.7f, 1f, 1f);

    [SerializeField]
    private Color hoverColor = new Color(0.4f, 0.8f, 1f, 1f);

    [SerializeField]
    private Color pressedColor = new Color(0.2f, 0.6f, 0.9f, 1f);

    [SerializeField]
    private Color disabledColor = new Color(0.5f, 0.5f, 0.5f, 1f);

    public event Action OnButtonClicked;

    private Vector3 originalScale;
    private bool isInteractable = true;
    private BoxCollider2D buttonCollider;

    void Awake()
    {
        originalScale = transform.localScale;
        buttonCollider = GetComponent<BoxCollider2D>();
        SetupButton();
    }

    private void SetupButton()
    {
        // Setup background with rounded corners effect
        if (backgroundRenderer != null)
        {
            backgroundRenderer.color = normalColor;
            backgroundRenderer.sortingOrder = 5;

            // Scale to create rounded rectangle appearance
            backgroundRenderer.transform.localScale = new Vector3(4f, 1.5f, 1f);
        }

        // Setup icon
        if (iconRenderer != null)
        {
            iconRenderer.color = Color.white;
            iconRenderer.sortingOrder = 10;
            iconRenderer.transform.localPosition = new Vector3(-0.5f, 0, -0.1f);
        }

        // Setup text
        if (buttonText != null)
        {
            buttonText.text = "UPDATE";
            buttonText.fontSize = 8f;
            buttonText.fontStyle = FontStyles.Bold;
            buttonText.alignment = TextAlignmentOptions.Center;
            buttonText.color = Color.white;
            buttonText.sortingOrder = 10;
            buttonText.transform.localPosition = new Vector3(0f, 0, -0.1f);
        }

        // Setup collider
        if (buttonCollider == null)
        {
            buttonCollider = gameObject.AddComponent<BoxCollider2D>();
        }

        buttonCollider.size = new Vector3(4f, 1.5f);
    }

    void OnMouseDown()
    {
        if (!isInteractable)
            return;

        // Visual feedback
        backgroundRenderer.color = pressedColor;
        transform.DOScale(originalScale * clickScale, animationDuration).SetEase(Ease.OutQuart);

        // Rotate icon for loading effect
        if (iconRenderer != null)
        {
            iconRenderer.transform.DORotate(new Vector3(0, 0, 180), animationDuration);
        }
    }

    void OnMouseUpAsButton()
    {
        if (!isInteractable)
            return;

        backgroundRenderer.color = normalColor;
        transform.DOScale(originalScale, animationDuration).SetEase(Ease.OutBack);

        // Reset icon rotation
        if (iconRenderer != null)
        {
            iconRenderer.transform.DORotate(Vector3.zero, animationDuration);
        }

        OnButtonClicked?.Invoke();
    }

    void OnMouseEnter()
    {
        if (!isInteractable)
            return;

        backgroundRenderer.color = hoverColor;
        transform.DOScale(originalScale * hoverScale, animationDuration).SetEase(Ease.OutQuart);
    }

    void OnMouseExit()
    {
        if (!isInteractable)
            return;

        backgroundRenderer.color = normalColor;
        transform.DOScale(originalScale, animationDuration).SetEase(Ease.OutQuart);
    }

    public void SetInteractable(bool interactable)
    {
        isInteractable = interactable;

        Color targetColor = interactable ? normalColor : disabledColor;
        Color textColor = interactable ? Color.white : new Color(0.7f, 0.7f, 0.7f);

        backgroundRenderer.color = targetColor;
        buttonText.color = textColor;

        if (iconRenderer != null)
        {
            iconRenderer.color = textColor;
        }
    }

    public void PlayLoadingAnimation()
    {
        if (iconRenderer != null)
        {
            iconRenderer
                .transform.DORotate(new Vector3(0, 0, 360), 1f, RotateMode.FastBeyond360)
                .SetLoops(-1, LoopType.Restart)
                .SetEase(Ease.Linear);
        }
    }

    public void StopLoadingAnimation()
    {
        if (iconRenderer != null)
        {
            iconRenderer.transform.DOKill();
            iconRenderer.transform.rotation = Quaternion.identity;
        }
    }
}


================================================================================
FILE: F:\Unity\TournamentLeaderboard\Assets\Scripts\Utils\ObjectPool.cs
================================================================================

using System.Collections.Generic;
using UnityEngine;

public class ObjectPool<T>
    where T : Component
{
    private Queue<T> pool = new Queue<T>();
    private T prefab;
    private Transform parent;

    public ObjectPool(T prefab, Transform parent, int initialSize = 10)
    {
        this.prefab = prefab;
        this.parent = parent;

        // Pre-instantiate objects
        for (int i = 0; i < initialSize; i++)
        {
            T obj = Object.Instantiate(prefab, parent);
            obj.gameObject.SetActive(false);
            pool.Enqueue(obj);
        }
    }

    public T Get()
    {
        if (pool.Count > 0)
        {
            T obj = pool.Dequeue();
            obj.gameObject.SetActive(true);
            return obj;
        }
        else
        {
            // Create new object if pool is empty
            T obj = Object.Instantiate(prefab, parent);
            obj.gameObject.SetActive(true);
            return obj;
        }
    }

    public void Return(T obj)
    {
        obj.gameObject.SetActive(false);
        pool.Enqueue(obj);
    }

    public void ReturnAll(List<T> objects)
    {
        foreach (T obj in objects)
        {
            Return(obj);
        }
        objects.Clear();
    }
}


